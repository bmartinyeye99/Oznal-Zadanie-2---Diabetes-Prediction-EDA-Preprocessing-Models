---
title: "zadanie_2_Branny_Bopko"
output: html_document
date: "2024-04-13"
---

```
Diabetes_binary : you have diabetes (0,1)

HighBP : Adults who have been told they have high blood pressure by a doctor, nurse, or other health professional (0,1)

HighChol : Have you EVER been told by a doctor, nurse or other health professional that your blood cholesterol is high? (0,1)

CholCheck : Cholesterol check within past five years (0,1)

BMI : Body Mass Index (BMI)

Smoker : Have you smoked at least 100 cigarettes in your entire life? [Note: 5 packs = 100 cigarettes] (0,1)

Stroke : (Ever told) you had a stroke. (0,1)

HeartDiseaseorAttack : Respondents that have ever reported having coronary heart disease (CHD) or myocardial infarction (MI) (0,1)

PhysActivity : Adults who reported doing physical activity or exercise during the past 30 days other than their regular job (0,1)

Fruits : Consume Fruit 1 or more times per day (0,1)

Veggies : Consume Vegetables 1 or more times per day (0,1)

HvyAlcoholConsump : Heavy drinkers (adult men having more than 14 drinks per week and adult women having more than 7 drinks per week)(0,1)

AnyHealthcare : Do you have any kind of health care coverage, including health insurance, prepaid plans such as HMOs, or government plans such as Medicare, or Indian Health Service? (0,1)

NoDocbcCost : Was there a time in the past 12 months when you needed to see a doctor but could not because of cost? (0,1)

GenHlth : Would you say that in general your health is: rate (1 ~ 5)

MentHlth : Now thinking about your mental health, which includes stress, depression, and problems with emotions, for how many days during the past 30 days was your mental health not good? (0 ~ 30)

PhysHlth : Now thinking about your physical health, which includes physical illness and injury, for how many days during the past 30 days was your physical health not good? (0 ~ 30)

DiffWalk : Do you have serious difficulty walking or climbing stairs? (0,1)

Sex : Indicate sex of respondent (0,1) (Female or Male)

Age : Fourteen-level age category (1 ~ 14)

Education : What is the highest grade or year of school you completed? (1 ~ 6)

Income : Is your annual household income from all sources: (If respondent refuses at any income level, code "Refused.") (1 ~ 8)
```




```{r}
library(leaps)
library(reshape2)
library(tidyverse)
library(magrittr) 
library(data.table) 
library(caret)
library(ggplot2)
library(readxl)
library(cowplot)
library(patchwork)
library(polycor)
library(psych)
library(caret)
library(caretEnsemble)
library(glmnet)
```
```{r}
setwd("./") 
list.files() 
```

## R Markdown
```{r}
data <- read.csv("diabetes_012_health_indicators_BRFSS2015.csv")
names(data)
head(data)
```
# Popis dát
```{r}
summary(data)
cat("Colnum : ", ncol(data),"\n")
cat("Rownum : ",nrow(data))
```


```{r}

#View(data)
```

```{r}
number_of_uniq_data <- sapply(data, function(x) length(unique(x)))
```


```{r}
cat("Unique values in dataset:\n")
print(number_of_uniq_data)
print("####")
print("Diabetes values :")
table(data$Diabetes_012, useNA = 'always')


```
Vidíme, že máme veľa binárnych hodnôt. Hodnoty, ktorými budeme pracovať pri vytáraní modelu budeme musieť enkódovať.
Náš label hodnota Diabetes_012 disponuje s 3 hodnotami. 0 - no diabetes 1 - prediabetes 2 - diabetes .

```{r}
sapply(data, class)
table(sapply(data, class))
sum(is.na(data))

```
Data obsahuju len numericke hodnoty a ziadne chýbajúce hodnoty.

```{r}
cat("Number of rows: ", nrow(data),"\n")
cat("Number of duplicates")
num_duplicates <- sum(duplicated(data))
print(num_duplicates)

# Remove duplicated rows
data <- data[!duplicated(data), ]

# Get the number of rows after deletion of duplicates
cat("Number of rows: ", nrow(data),"\n")

```



```{r}
data <- data %>% 
  mutate(
    Diabetes = case_when(
      Diabetes_012 %in% c(1, 2) ~ 1,
      Diabetes_012 == 0 ~ 0
    )
  ) %>%
  select(-Diabetes_012)
```


```{r}
print("Diabetes values :")
table(data$Diabetes, useNA = 'always')
```
Mergovali sme hodnoty 1 a 2, a tych ktori maju 1 (prediabetes) budeme brat ako keby uz mali daibete (2).

```{r}

numeric_columns <- sapply(data, is.numeric)  # Identify numeric columns
non_binary_numeric_columns <- numeric_columns & !apply(data, 2, function(x) all(x %in% c(0, 1)))
nonbinarycolumns <- names(non_binary_numeric_columns[non_binary_numeric_columns])

print_histograms <- function(data, columns) {
  for (col_name in columns) {
    
    if (col_name == "BMI"){
      p <- ggplot(data, aes(x = BMI)) + 
      geom_histogram(fill = "skyblue", color = "black") +
      ggtitle("Distribution of BMI") + 
      xlab("BMI") + 
      ylab("Count")
        print(p)
    }
    else{
    data[[col_name]] <- factor(data[[col_name]])
    p <- ggplot(data, aes_string(x = col_name)) +
      geom_bar(fill = "skyblue", color = "black") +
      scale_x_discrete(drop = FALSE) +  # Ensure all unique values are shown on x-axis
      theme_minimal() +
      ggtitle(paste("Distribution of", col_name)) +
      xlab(col_name) +
      ylab("Count")
    print(p)
    }
  }
}



print_histograms(data, nonbinarycolumns)

```

```{r}

```



```{r}

# Define the columns of interest
columns_of_interest <- c('BMI', 'GenHlth', 'MentHlth', 'PhysHlth', 'Age', 'Education', 'Income')

# Create a list to store individual boxplot plots
plots <- list()

# Loop through each column and create a boxplot
for (i in 1:length(columns_of_interest)) {
  col <- columns_of_interest[i]
  p <- ggplot(data, aes_string(x = col)) +
    geom_boxplot(fill = "skyblue", color = "black") +
    ggtitle(paste("Distribution of", col)) +
    theme_minimal(base_size = 8) +  # Set base font size
    theme(axis.text.x = element_text(size = 6),  # Set x-axis text size
          axis.text.y = element_text(size = 6)) +  # Set y-axis text size
    xlab(col) +
    ylab("Value")
  plots <- c(plots, list(p))  # Append each plot to the list
}

# Combine plots into a single plot grid
combined_plot <- cowplot::plot_grid(plotlist = plots, nrow = 4, ncol = 2)

# Adjust the size of the combined plot
ggsave("combined_plot.png", combined_plot, width = 10, height = 10)

# Print the combined plot
print(combined_plot)

```
Na základe týchto grafov, žiadné stĺpce neobsahujú hodnoty, ktoré by boli nižšie alebo vačšie ako zadefiované extrémy týchto stlpcov. 


```{r}
handle_outliers <- function(data, columns, sensitivity) {
  na_counts <- setNames(numeric(length(columns)), columns)  # Initialize a vector to hold NA counts for each column
  totalNumOfOutliers = 0
  for (col in columns) {
    # Count NAs before handling outliers
    na_count_before <- sum(is.na(data[[col]]))
    
    # Calculate quartiles and IQR
    q1 <- quantile(data[[col]], 0.25, na.rm = TRUE)
    q3 <- quantile(data[[col]], 0.75, na.rm = TRUE)
    iqr <- q3 - q1
    
    # Define upper and lower bounds for outliers
    upper_bound <- q3 + iqr*sensitivity
    lower_bound <- q1 - iqr*sensitivity
    
    print(paste("Upper bound for", col, ":", upper_bound))
    print(paste("Lower bound for", col, ":", lower_bound))
    # Replace outliers with NA
    data[[col]] <- ifelse(data[[col]] < lower_bound | data[[col]] > upper_bound, NA, data[[col]])
    
    # Count NAs after handling outliers
    na_count_after <- sum(is.na(data[[col]]))
    
    # Calculate the number of NAs added
    na_counts[col] <- na_count_after - na_count_before
    totalNumOfOutliers = totalNumOfOutliers + na_counts
    # Print the number of NAs added for the current column
    cat("NAs added in", col, ":", na_counts[col], "\n")
  }
      data <- na.omit(data)
  cat("Total number of outliers detected : ", totalNumOfOutliers)
  # Return the cleaned data and the NA counts
  return(data)
}
```

```{r}
# Function returns names of non binary columns
non_binary_columns <- function(data) {
  non_binary_cols <- character(0)  # Initialize an empty vector to store non-binary column names
  for (col in names(data)) {
    unique_vals <- unique(data[[col]])
    if (length(unique_vals) > 2) {
      non_binary_cols <- c(non_binary_cols, col)  # Add column name to the list of non-binary columns
    }
  }
  return(non_binary_cols)
}

# Usage:
nonbinarycolumns <- non_binary_columns(data)
nonbinarycolumns <- non_binary_columns(data)
cat("Non binary columns : ",nonbinarycolumns)

dataWithOutliers <- data
data <- handle_outliers(data, nonbinarycolumns, 0.5)
```



```{r}
library(ggplot2)
library(reshape2)

# Function to generate heatmap for correlation matrix
generate_correlation_heatmap <- function(correlation_matrix, title) {
  numsize = 1.9
  if ( title == "Correlation of Features - Non-Binary Columns")
    numsize = 2.5
  else
    numsize = 1.9
  # Convert correlation matrix to dataframe
  correlation_df <- as.data.frame(correlation_matrix)
  correlation_df$row <- rownames(correlation_matrix)

  # Melt dataframe to long format
  correlation_df_long <- melt(correlation_df, id.vars = "row")

  # Set the size of the plot
  options(repr.plot.width = 10, repr.plot.height = 8)

  # Plot heatmap
  ggplot(data = correlation_df_long, aes(x = row, y = variable, fill = value)) +
    geom_tile(color = "white") +
    geom_text(aes(label = round(value, 2)), color = "black", size = numsize) +
    scale_fill_gradient2(low = "blue", high = "red", na.value = "white", limits = c(-1, 1), name = "Correlation") +
    theme_minimal() +
    labs(title = title) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x-axis labels
}

# Compute correlation matrix for the entire dataset
correlation_matrix <- cor(data)

# Generate heatmap for entire dataset
generate_correlation_heatmap(correlation_matrix, "Correlation of Features - Entire Dataset")

# Compute correlation matrix for non-binary columns
correlation_matrix_nonbinary <- cor(data[, nonbinarycolumns])

# Generate heatmap for non-binary columns
generate_correlation_heatmap(correlation_matrix_nonbinary, "Correlation of Features - Non-Binary Columns")

```
Na grafe je vidno, že viacere  hodnoty sa korelujú. Dokonca máme aj negatívne korlácie.
Z tychto hodnot nedozvieme vsetko, ale napr. mozeme mat predpoklad, ze cim starsi je clovek, tym menej zaraba, alebo cim viac zaraba clovek, tym ma vacsie vzdelanie.

Klucove info z tejto tabulky su napr:, age, GenHlth, BMI, MentlHlth, PhysHlth



Vypocitame korelácie medzi kategorickými hodnotami, ktoré rozdelujeme na nominalne a ordinalne.
```{r}
ordinal_categorical_columns <- c("Education", "Income", "GenHlth")

binary_cols <- c('HighBP', 'HighChol', 'CholCheck', 'Smoker',
          'Stroke', 'HeartDiseaseorAttack', 'PhysActivity', 'Veggies',
          'HvyAlcoholConsump', 'AnyHealthcare', 'NoDocbcCost', 'DiffWalk', 'Diabetes')

all_categorical_values <-c('HighBP', 'HighChol', 'CholCheck', 'Smoker',
          'Stroke', 'HeartDiseaseorAttack', 'PhysActivity', 'Veggies',
          'HvyAlcoholConsump', 'AnyHealthcare', 'NoDocbcCost', 'DiffWalk', 'Diabetes', "Education", "Income", "GenHlth")

binary_data <- data[, binary_cols]
ordinal_data <- data[, ordinal_categorical_columns]

# Calculate Tetrachoric correlation for binary columns
tetrachoric_corr <- tetrachoric(binary_data)

# Print the results
print("Tetrachoric Correlation for Binary Columns:")
print(tetrachoric_corr)

```
Vypocitali sme korelacie medzi nominalnymi kategorickými hodnotami. Tieto výsledky nám pomozu si vytvorit model, kedze vidíme vztahy medzi hodnotou Diabetes co chceme predikovat, a ostatnými hodnotami.
Napr. HighBP a Diabetes maju mierne velku korelcáie, preto si predpokladáme, že vyssi krvný tlak a srdcové ochorenia znamenaju vacsiu sancu na diabetes.

Na druhej strane, fyzická aktivita, konzumovanie zelenín a absolvovanie preventívnych návštev lekára - čiže keď sa nenastala taká situácia, že doktor nebol navštevovaný, ked by mal byt - NoDocbcCost, znižujú šancu Diabetes. Prekvapivo aj konzumácia alkoholu.


Klucove info: HighBP, HighChl, Chlch, HrtDa,, HvyAc, Stroke, AnyHL
```{r}
# Calculate Polychoric correlation for ordinal columns
polychoric_corr <- polychoric(ordinal_data)

print("###########")

print("Polychoric Correlation for Ordinal Columns:")
print(polychoric_corr)
```




```{r}
print(nonbinarycolumns)
plots <- list()

all_categorical_values_without_diabetes <-c('HighBP', 'HighChol', 'CholCheck', 'Smoker',
          'Stroke', 'HeartDiseaseorAttack', 'PhysActivity', 'Veggies',
          'HvyAlcoholConsump', 'AnyHealthcare', 'NoDocbcCost', 'DiffWalk', "Education", "Income", "GenHlth")
# Create stacked barplots for categorical values and Diabetes
for (col in all_categorical_values_without_diabetes) {
  
  # Create bar plot
  plot <- data %>%
    mutate(Diabetes = factor(Diabetes)) %>% # Convert Diabetes to factor
    group_by(Diabetes, !!sym(col)) %>%
    summarise(Count = n()) %>%
    ggplot(aes(fill = Diabetes, y = Count, x = !!sym(col))) + 
    geom_bar(position = 'stack', stat = 'identity') +
    theme_minimal() + 
    labs(x = col, y = "Count", title = paste("Distribution of Diabetes in ", col)) +
    theme(plot.title = element_text(hjust = 0.5, size = 12, face = 'bold')) +
    scale_fill_manual('Diabetes', values = c('lightblue', 'coral'))
  
  
   # Store the plot
   plots[[col]] <- plot
 }

 # Print the plots
 for (i in seq_along(plots)) {
  print(plots[[i]])
 }
```


Na tychto grafoch vidíme ditribúciu Diabetes medzi ostatnými binárnými hodnotami. O4ividne sú viac diabetikov medzi jednotlivcami, ktorí maju vysoky cholesterol, krvný tlak, alebo medzi tými ktorí uz mali stroke


```{r}


diabetes_percentage <- data %>%
  group_by(Diabetes) %>%
  summarise(Count = n()) %>%
  mutate(Percentage = prop.table(Count) * 100)

# Create pie chart
piechart <- ggplot(diabetes_percentage, aes(x = "", y = Percentage, fill = factor(Diabetes))) +
  geom_bar(stat = "identity", width = 1) +
  geom_text(aes(label = paste(round(Percentage, 1), "%")), position = position_stack(vjust = 0.5)) +  # Add percentage labels
  coord_polar(theta = "y") +
  labs(fill = "Diabetes", title = "Percentage Distribution of Diabetes") +
  theme_void() +
  theme(legend.position = "bottom")  # Move legend to the bottom

# Print pie chart
print(piechart)
```

Okrem korelácie, pouzivame regsubsets aby sme nasli najlepsie predictory pre BMI
```{r}
# Perform best subset regression
Best_Subset <- regsubsets(BMI ~ .,
                          data = data,
                          nbest = 1,      # 1 best model for each number of predictors
                          nvmax = NULL,   # NULL for no limit on number of variables
                          force.in = NULL, force.out = NULL,
                          method = "exhaustive")

# Summarize the results
summary_best_subset <- summary(Best_Subset)

# View the summary output
summary_best_subset
which.max(summary_best_subset$adjr2)
summary_best_subset$which[21,]
```
<!-- Hviezdičky ( * ) v dolnej časti výstupu označujú, ktoré predikčné premenné patria do najlepšieho regresného modelu pre každý možný model s rôznym počtom predikčných premenných. -->


<!-- Pre model s jednou prediktorovou premennou je najlepším regresným modelom model, v ktorom sa ako prediktorová premenná použije HighBP -->
<!-- V prípade modelu s dvoma prediktorovými premennými sa najlepší regresný model vytvorí použitím Diabetes a HighBP ako prediktorových premenných. -->



# Linear regression model
```{r}
model <- data %$% 
  lm(BMI ~ Age + GenHlth + HighBP + Diabetes + Sex )

summary(model)
```
Celkovo model naznačuje, že Age, General Health, High Blood Pressure, Diabetes, and Sex sú významnými prediktormi BMI. Model však vysvetľuje len malú časť rozptylu BMI (adjusted R-squared = 0.07293), čo naznačuje, že BMI môžu ovplyvňovať aj iné faktory, ktoré nie sú zahrnuté v modeli.

Intercept: Priemerná hodnota BMI, keď sú všetky ostatné premenné nulové, je 26.70. Tento koeficient je štatisticky významný (p \< 0.05).

-   Age: Za každú jednotku zvýšenia veku (Age) sa BMI zníži o -0.19, čo je štatisticky významné (p \< 0.05). Aj keď vplyv malý, je považovaný za štatisticky signifikantný.

Ak má osoba vysoký krvný tlak (HighBP = 1), očakáva sa, že jej BMI bude v priemere vyšší približne o 1,337023 jednotky v porovnaní s osobou bez vysokého krvného tlaku (HighBP = 0), pričom sa kontrolujú ostatné premenné v modeli.



Plottig reg lines for predictors
```{r}
ggplotRegression <- function(fit) {
  require(ggplot2)
  
  predictors <- names(fit$model)[-1]  # Exclude the response variable
  
  plots <- list()
  
  for (predictor in predictors) {
    plot <- ggplot(fit$model, aes_string(x = predictor, y = names(fit$model)[1])) + 
      geom_point() +
      stat_smooth(method = "lm", col = "red") +
      labs(title = paste("Adj R2 =", signif(summary(fit)$adj.r.squared, 5),
                         "Intercept =", signif(coef(fit)[1], 5),
                         "Slope =", signif(coef(fit)[predictor], 5),
                         "P =", signif(summary(fit)$coef[which(rownames(summary(fit)$coef) == predictor), "Pr(>|t|)"], 5)))
    
    plots[[predictor]] <- plot
  }
  
  return(plots)
}

plots <- ggplotRegression(model)

for (predictor in names(plots)) {
  print(plots[[predictor]])
}

```
Defining LASSO model
```{r}
# Define the control using a random forest selection function
control <- rfeControl(functions = rfFuncs, # random forest
                      method = "repeatedcv", # repeated cv
                      repeats = 5, # number of repeats
                      number = 10) # number of folds
```

```{r}
library(randomForest)
```


RFE for feature selection, runs very long - dont know wether we have to use it 
```{r}
# # Features
# x <- data %>%
#   select(-BMI) %>%
#   as.data.frame()
# 
# # Target variable
# y <- data$BMI
# 
# # Training: 80%; Test: 20%
# set.seed(2021)
# inTrain <- createDataPartition(y, p = .80, list = FALSE)[,1]
# 
# x_train <- x[inTrain, ]
# x_test  <- x[-inTrain, ]
# 
# y_train <- y[inTrain]
# y_test  <- y[-inTrain]
# 
# # Define resampling control
# control <- rfeControl(functions = rfFuncs, method = "cv", number = 5)
# 
# # Run RFE
# result_rfe1 <- rfe(x = x_train, 
#                    y = y_train, 
#                    sizes = c(1:ncol(x_train)),
#                    rfeControl = control)
# 
# # Print the results
# print(result_rfe1)
# 
# # Print the selected features
# print(predictors(result_rfe1))
# 
# # # Print the results visually
# # ggplot(data = result_rfe1, aes(x = Variables, y = Accuracy)) + geom_point() + theme_bw()
# # ggplot(data = result_rfe1, aes(x = Variables, y = Kappa)) + geom_point() + theme_bw()

```


```{r}
# Assuming 'data' is your dataframe containing the variables
# Set the seed for reproducibility
# Assuming 'data' is your original dataframe containing all the data

# Set the seed for reproducibility
set.seed(123)

# Split the dataset into training (80%) and testing (20%) sets
train_indices <- sample(1:nrow(data), 0.8 * nrow(data))
train_data <- data[train_indices, ]


test_data <- data[-train_indices, ]
print(colnames(train_data))
# Prepare the training data
x_train <- train_data[, c("Age", "GenHlth", "HighBP", "Diabetes" , "Sex" )]
y_train <- train_data$BMI

# Prepare the testing data
x_test <- test_data[, c("Age", "GenHlth", "HighBP", "Diabetes", "Sex")]
y_test <- test_data$BMI

# Fit the LASSO regression model
fit_lasso <- glmnet(as.matrix(x_train), y_train, alpha = 1)

# Select the optimal lambda (tuning parameter) using cross-validation
cv_fit <- cv.glmnet(as.matrix(x_train), y_train, alpha = 1)
lambda_optimal <- cv_fit$lambda.min

# Extract coefficients
coef_lasso <- coef(fit_lasso, s = lambda_optimal)

# Make predictions on the testing data
predictions <- predict(fit_lasso, newx = as.matrix(x_test), s = lambda_optimal)

# You can use metrics such as mean squared error (MSE), R-squared, etc.
mse <- mean((predictions - y_test)^2)
rsquared <- cor(predictions, y_test)^2

# Print the evaluation metrics
cat("Mean Squared Error (MSE):", mse, "\n")
cat("R-squared:", rsquared, "\n")

```
Dostali sme skoro rovnake vysledky ako s linearnou regresiou. R squared je 0.076 co znamena ze prediktory su zodpovedne za 7.6 % variancie BMI, co je relativne malo. 

Priemern8 chyba predikcie a realnej hodnoty je  14.64678., co je vysoke. Takyto rozdiel v BMI vyrazne zmeni stav cloveka.
